#include "bytecode_test_helpers.hpp"
#include "test_stubs.hpp"
#include <gtest/gtest.h>
#include <vector>
#include <cstdint>

using namespace test_helpers;

/**
 * Test Pattern:
 * 1. Create a CompiledMethod in memory with bytecode
 * 2. Create a Context for executing the method
 * 3. Step forward one instruction
 * 4. Check the post conditions
 */

// ============================================================================
// PUSH_LITERAL (opcode 0)
// ============================================================================

/**
 * Test PUSH_LITERAL instruction
 * 
 * Format: 00 [index:uint32_le]
 * Stack: ... → ..., literal
 * 
 * Post conditions:
 * - Stack depth increased by 1
 * - Top of stack equals literals[index]
 * - Instruction pointer advanced by 5
 */
TEST(BytecodeInstructions, PushLiteral_Basic) {
    // Arrange: Create bytecode for PUSH_LITERAL with index 0
    std::vector<uint8_t> bytecode = encodeInstruction(0, {0}); // PUSH_LITERAL index 0
    
    // Create literals array
    std::vector<TaggedValue> literals = {
        makeSmallInteger(42)
    };
    
    // Create CompiledMethod
    auto method = createCompiledMethod(bytecode, literals);
    
    // Create Context with receiver (self)
    TaggedValue receiver = makeSmallInteger(0); // self
    auto context = createContext(method.get(), receiver);
    
    // Pre-conditions
    ASSERT_EQ(getStackDepth(context.get()), 0);
    ASSERT_EQ(getInstructionPointer(context.get()), 0);
    
    // Act: Step forward one instruction
    bool success = stepInstruction(context.get());
    
    // Assert: Post conditions
    ASSERT_TRUE(success) << "Instruction should execute successfully";
    ASSERT_EQ(getStackDepth(context.get()), 1) << "Stack depth should increase by 1";
    ASSERT_EQ(getStackTop(context.get()), literals[0]) << "Stack top should equal literal[0]";
    ASSERT_EQ(getInstructionPointer(context.get()), 5) << "Instruction pointer should advance by 5 bytes";
}

TEST(BytecodeInstructions, PushLiteral_Index1) {
    // Arrange: PUSH_LITERAL with index 1
    std::vector<uint8_t> bytecode = encodeInstruction(0, {1}); // PUSH_LITERAL index 1
    
    std::vector<TaggedValue> literals = {
        makeSmallInteger(10),
        makeSmallInteger(20)
    };
    
    auto method = createCompiledMethod(bytecode, literals);
    auto context = createContext(method.get(), makeSmallInteger(0));
    
    // Act
    bool success = stepInstruction(context.get());
    
    // Assert
    ASSERT_TRUE(success);
    ASSERT_EQ(getStackDepth(context.get()), 1);
    ASSERT_EQ(getStackTop(context.get()), literals[1]) << "Should push literal[1]";
    ASSERT_EQ(getInstructionPointer(context.get()), 5);
}

TEST(BytecodeInstructions, PushLiteral_NonEmptyStack) {
    // Arrange: Start with items on stack
    std::vector<uint8_t> bytecode = encodeInstruction(0, {0});
    std::vector<TaggedValue> literals = {makeSmallInteger(99)};
    
    auto method = createCompiledMethod(bytecode, literals);
    auto context = createContext(method.get(), makeSmallInteger(0));
    
    // Pre-populate stack (this would be done via helper or previous instructions)
    // For now, we'll test that the stack grows correctly
    
    // Act
    bool success = stepInstruction(context.get());
    
    // Assert
    ASSERT_TRUE(success);
    auto stack = getStack(context.get());
    ASSERT_EQ(stack.size(), 1);
    ASSERT_EQ(stack[0], literals[0]);
}

TEST(BytecodeInstructions, PushLiteral_IndexOutOfBounds) {
    // Arrange: Try to access literal index that doesn't exist
    std::vector<uint8_t> bytecode = encodeInstruction(0, {5}); // Index 5
    std::vector<TaggedValue> literals = {makeSmallInteger(42)}; // Only 1 literal
    
    auto method = createCompiledMethod(bytecode, literals);
    auto context = createContext(method.get(), makeSmallInteger(0));
    
    // Act
    bool success = stepInstruction(context.get());
    
    // Assert: Should fail with IndexError
    ASSERT_FALSE(success) << "Should fail when literal index is out of bounds";
    // TODO: Check for specific error type (IndexError)
}

// ============================================================================
// PUSH_SELF (opcode 3)
// ============================================================================

/**
 * Test PUSH_SELF instruction
 * 
 * Format: 03
 * Stack: ... → ..., self
 * 
 * Post conditions:
 * - Stack depth increased by 1
 * - Top of stack equals context's self
 * - Instruction pointer advanced by 1
 */
TEST(BytecodeInstructions, PushSelf_Basic) {
    // Arrange
    std::vector<uint8_t> bytecode = {3}; // PUSH_SELF (no operands)
    std::vector<TaggedValue> literals = {};
    
    auto method = createCompiledMethod(bytecode, literals);
    TaggedValue receiver = makeSmallInteger(42);
    auto context = createContext(method.get(), receiver);
    
    // Pre-conditions
    ASSERT_EQ(getStackDepth(context.get()), 0);
    
    // Act
    bool success = stepInstruction(context.get());
    
    // Assert
    ASSERT_TRUE(success);
    ASSERT_EQ(getStackDepth(context.get()), 1);
    ASSERT_EQ(getStackTop(context.get()), receiver) << "Stack top should equal self (receiver)";
    ASSERT_EQ(getInstructionPointer(context.get()), 1) << "Instruction pointer should advance by 1 byte";
}

// ============================================================================
// POP (opcode 11)
// ============================================================================

/**
 * Test POP instruction
 * 
 * Format: 0B
 * Stack: ..., value → ...
 * 
 * Post conditions:
 * - Stack depth decreased by 1
 * - Value removed from stack
 * - Instruction pointer advanced by 1
 */
TEST(BytecodeInstructions, Pop_Basic) {
    // Arrange: Create bytecode that pushes a value then pops it
    std::vector<uint8_t> bytecode;
    auto pushLiteral = encodeInstruction(0, {0}); // PUSH_LITERAL 0
    bytecode.insert(bytecode.end(), pushLiteral.begin(), pushLiteral.end());
    bytecode.push_back(11); // POP
    
    std::vector<TaggedValue> literals = {makeSmallInteger(42)};
    
    auto method = createCompiledMethod(bytecode, literals);
    auto context = createContext(method.get(), makeSmallInteger(0));
    
    // Execute PUSH_LITERAL first
    stepInstruction(context.get());
    ASSERT_EQ(getStackDepth(context.get()), 1);
    
    // Act: Execute POP
    bool success = stepInstruction(context.get());
    
    // Assert
    ASSERT_TRUE(success);
    ASSERT_EQ(getStackDepth(context.get()), 0) << "Stack should be empty after POP";
    ASSERT_EQ(getInstructionPointer(context.get()), 6) << "IP should be at byte 6 (5 for PUSH_LITERAL + 1 for POP)";
}

TEST(BytecodeInstructions, Pop_StackUnderflow) {
    // Arrange: Try to POP from empty stack
    std::vector<uint8_t> bytecode = {11}; // POP
    std::vector<TaggedValue> literals = {};
    
    auto method = createCompiledMethod(bytecode, literals);
    auto context = createContext(method.get(), makeSmallInteger(0));
    
    // Pre-condition: Stack is empty
    ASSERT_EQ(getStackDepth(context.get()), 0);
    
    // Act
    bool success = stepInstruction(context.get());
    
    // Assert: Should fail with StackUnderflowError
    ASSERT_FALSE(success) << "Should fail when popping from empty stack";
}

// ============================================================================
// Test Runner Main
// ============================================================================

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

---
#pragma once

#include "test_stubs.hpp"
#include <vector>
#include <cstdint>
#include <memory>

// Forward declarations
class VM;

namespace test_helpers {

/**
 * Create a CompiledMethod in memory with specified bytecode and literals
 */
std::unique_ptr<CompiledMethod> createCompiledMethod(
    const std::vector<uint8_t>& bytecode,
    const std::vector<TaggedValue>& literals = {},
    uint32_t numArgs = 0,
    uint32_t numTemps = 0,
    uint32_t primitiveNumber = 0
);

/**
 * Create a Context for executing a method
 */
std::unique_ptr<Context> createContext(
    CompiledMethod* method,
    TaggedValue receiver,
    const std::vector<TaggedValue>& args = {}
);

/**
 * Step forward one instruction in the context
 * Returns true if instruction executed successfully, false otherwise
 */
bool stepInstruction(Context* context);

/**
 * Get the current instruction pointer
 */
uint32_t getInstructionPointer(Context* context);

/**
 * Get the stack as a vector (for testing)
 */
std::vector<TaggedValue> getStack(Context* context);

/**
 * Get the top of the stack
 */
TaggedValue getStackTop(Context* context);

/**
 * Get the stack depth
 */
size_t getStackDepth(Context* context);

/**
 * Create a TaggedValue from a SmallInteger
 */
TaggedValue makeSmallInteger(int32_t value);

/**
 * Create a TaggedValue for nil
 */
TaggedValue makeNil();

/**
 * Create a TaggedValue for true
 */
TaggedValue makeTrue();

/**
 * Create a TaggedValue for false
 */
TaggedValue makeFalse();

/**
 * Encode a bytecode instruction with operands
 */
std::vector<uint8_t> encodeInstruction(uint8_t opcode, const std::vector<uint32_t>& operands = {});

/**
 * Encode a 32-bit little-endian value
 */
void encodeUint32LE(std::vector<uint8_t>& bytes, uint32_t value);

} // namespace test_helpers

---
#include "bytecode_test_helpers.hpp"
#include "test_stubs.hpp"
#include <cstring>
#include <stdexcept>
#include <cstdint>
#include <memory>

// TODO: Include actual headers when they're implemented
// #include "src/tagged_value.hpp"
// #include "src/method.hpp"
// #include "src/context.hpp"
// #include "src/interpreter.hpp"

namespace test_helpers {

void encodeUint32LE(std::vector<uint8_t>& bytes, uint32_t value) {
    bytes.push_back(static_cast<uint8_t>(value & 0xFF));
    bytes.push_back(static_cast<uint8_t>((value >> 8) & 0xFF));
    bytes.push_back(static_cast<uint8_t>((value >> 16) & 0xFF));
    bytes.push_back(static_cast<uint8_t>((value >> 24) & 0xFF));
}

std::vector<uint8_t> encodeInstruction(uint8_t opcode, const std::vector<uint32_t>& operands) {
    std::vector<uint8_t> bytes;
    bytes.push_back(opcode);
    
    for (uint32_t operand : operands) {
        encodeUint32LE(bytes, operand);
    }
    
    return bytes;
}

// Placeholder implementations - these will be replaced with actual implementations
// once the VM classes are created

std::unique_ptr<CompiledMethod> createCompiledMethod(
    const std::vector<uint8_t>& bytecode,
    const std::vector<TaggedValue>& literals,
    uint32_t numArgs,
    uint32_t numTemps,
    uint32_t primitiveNumber
) {
    // Stub implementation - returns a CompiledMethod with the provided data
    return std::make_unique<CompiledMethod>(bytecode, literals, numArgs, numTemps, primitiveNumber);
}

std::unique_ptr<Context> createContext(
    CompiledMethod* method,
    TaggedValue receiver,
    const std::vector<TaggedValue>& /* args */
) {
    // Stub implementation - creates a Context with the method and receiver
    return std::make_unique<Context>(method, receiver);
}

bool stepInstruction(Context* context) {
    // TODO: Implement when Interpreter class exists
    // For now, just throw to indicate not implemented
    throw std::runtime_error("stepInstruction not yet implemented - need Interpreter");
}

uint32_t getInstructionPointer(Context* context) {
    if (!context) throw std::runtime_error("Context is null");
    return context->instructionPointer;
}

std::vector<TaggedValue> getStack(Context* context) {
    if (!context) throw std::runtime_error("Context is null");
    return context->stack;
}

TaggedValue getStackTop(Context* context) {
    if (!context) throw std::runtime_error("Context is null");
    if (context->stack.empty()) throw std::runtime_error("Stack is empty");
    return context->stack.back();
}

size_t getStackDepth(Context* context) {
    if (!context) throw std::runtime_error("Context is null");
    return context->stack.size();
}

TaggedValue makeSmallInteger(int32_t value) {
    // Stub: encode as (value << 2) | 0x03
    uintptr_t encoded = (static_cast<uintptr_t>(value) << 2) | 0x03;
    return TaggedValue(encoded);
}

TaggedValue makeNil() {
    return TaggedValue(0x00000001);
}

TaggedValue makeTrue() {
    return TaggedValue(0x00000005);
}

TaggedValue makeFalse() {
    return TaggedValue(0x00000009);
}

} // namespace test_helpers

